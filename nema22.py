ì½˜í…ì¸ ë¡œ ê±´ë„ˆë›°ê¸°
ì±„íŒ… ê¸°ë¡

ë‚˜ì˜ ë§:
nema24 tb6600ì´ 4ê°œ ì—°ê²° ëì„ ë•Œ ì „ë¥˜ì™€ ì „ì••ì„ ê³„ì‚°í•´ë´
ChatGPTì˜ ë§:

23s ë™ì•ˆ ìƒê°í•¨
ì¢‹ì•„ìš”. â€œNEMA24 ìŠ¤í…ëª¨í„° Ã— 4ê°œë¥¼ TB6600 ë“œë¼ì´ë²„ 4ê°œì— ê°ê° ë¬¼ë ¸ì„ ë•Œ ì „ì›(ì „ì••/ì „ë¥˜)ì„ ì–´ë–»ê²Œ ì¡ëŠëƒâ€ë¥¼ ê°„ë‹¨ ê³µì‹ + ì˜ˆì‹œë¡œ ì •ë¦¬í•´ë“œë¦´ê²Œìš”.

1) ì „ì••(PSU Voltage)
TB6600 ê¶Œì¥ ì…ë ¥: ë³´í†µ 24 V ~ 36 V(ë“œë¼ì´ë²„ ìŠ¤í™ ìƒí•œ ë‚´ì—ì„œ).

ì„ íƒ ê¸°ì¤€: ì „ì••ì´ ë†’ì„ìˆ˜ë¡ ê³ ì† í† í¬/ì†ë„ ì—¬ìœ ê°€ ìƒê¹ë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ 24 Vê°€ ë¬´ë‚œ, ì†ë„ ì—¬ìœ ê°€ ë” í•„ìš”í•˜ë©´ 36 V.

ëª¨í„° ì •ê²© ì „ì••ì€ â€˜ì½”ì¼ ì €í•­ Ã— ì •ê²©ì „ë¥˜â€™ë¡œ ë‚®ê²Œ ë‚˜ì˜¤ì§€ë§Œ, ì´ˆí¼ ë“œë¼ì´ë²„(TB6600)ëŠ” ì •ê²©ì „ë¥˜ ê¸°ì¤€ìœ¼ë¡œ ì „ì••ì„ ë†’ê²Œ ì¨ë„ OKì…ë‹ˆë‹¤(ë“œë¼ì´ë²„ê°€ ì „ë¥˜ë¥¼ ì œí•œ).

2) ì „ë¥˜(PSU Current) ê³„ì‚° ê³µì‹
ì´ˆí¼ ë“œë¼ì´ë²„ ì‚¬ìš© ì‹œ ì „ì›ì—ì„œ ëŒì–´ì˜¤ëŠ” í‰ê·  ì „ë¥˜ëŠ” ëª¨í„° ì •ê²©ì „ë¥˜ í•©ë³´ë‹¤ ì‘ìŠµë‹ˆë‹¤. ë³´ìˆ˜ì ìœ¼ë¡œ ì•„ë˜ ê²½í—˜ ë²•ì¹™ì„ ë§ì´ ì”ë‹ˆë‹¤.

PSU ì „ë¥˜ ì¶”ì •ì‹(ê²½í—˜ì¹™):

I
PSU
â‰ˆ
0.67
Ã—
I
phase
Ã—
N
motors
I 
PSU
â€‹
 â‰ˆ0.67Ã—I 
phase
â€‹
 Ã—N 
motors
â€‹
 
I
phase
I 
phase
â€‹
 : ëª¨í„° ì •ê²©(ë˜ëŠ” ë“œë¼ì´ë²„ ì„¤ì •) ì „ë¥˜/ìƒ(A)

N
motors
=
4
N 
motors
â€‹
 =4

ë§ˆì§€ë§‰ì— ì—¬ìœ  20~50% ë”í•˜ì„¸ìš”(ì „ì›Â·ë°°ì„  ì—¬ìœ /ë™ì‹œë¶€í•˜ ëŒ€ë¹„).

ì™œ 0.67?
ë¯¸ì„¸ìŠ¤í…ì—ì„œ ë‘ ìƒì´ ë²ˆê°ˆì•„/ë™ì‹œì— ë¶€ë¶„ì ìœ¼ë¡œ ë„í†µë˜ë©°, ë“œë¼ì´ë²„ì˜ ì „ë¥˜ ë¦¬ì‚¬ì´í´ë§ íŠ¹ì„± ë•Œë¬¸ì— ì „ì›ì—ì„œ ë³´ëŠ” í‰ê·  ì „ë¥˜ê°€ ìƒì „ë¥˜ì˜ ì•½ 2/3 ìˆ˜ì¤€ì¸ ê²½ìš°ê°€ ë§ìŠµë‹ˆë‹¤. (ë³´ìˆ˜ì ìœ¼ë¡œ ì¡ê³ , ì—¬ìœ ë¶„ ì¶”ê°€ê°€ í•µì‹¬!)

3) ì˜ˆì‹œ ê³„ì‚°
ì˜ˆì‹œ A) NEMA24 = 3.0 A/ìƒ
4ê°œ ëª¨í„°, 
I
phase
=
3.0
I 
phase
â€‹
 =3.0 A

ê¸°ë³¸ ì¶”ì •: 
0.67
Ã—
3.0
Ã—
4
=
8.04
0.67Ã—3.0Ã—4=8.04 A

ì—¬ìœ  +30% â†’ ì•½ 10.5 A

ê¶Œì¥ PSU: 24 V 12 A (ë˜ëŠ” 24 V 15 A)

ì „ë ¥ ì˜ˆì‚°: 
P
â‰ˆ
24
Ã—
10.5
â‰ˆ
252
Pâ‰ˆ24Ã—10.5â‰ˆ252 W (12 A PSUë©´ 288 Wê¸‰)

ì˜ˆì‹œ B) NEMA24 = 4.2 A/ìƒ
ê¸°ë³¸ ì¶”ì •: 
0.67
Ã—
4.2
Ã—
4
=
11.26
0.67Ã—4.2Ã—4=11.26 A

ì—¬ìœ  +30% â†’ ì•½ 14.6 A

ê¶Œì¥ PSU: 24 V 15 A (ì—¬ìœ  ë„‰ë„‰íˆ 24 V 20 Aë„ ì¢‹ìŒ)

ì „ë ¥ ì˜ˆì‚°: 
P
â‰ˆ
24
Ã—
14.6
â‰ˆ
350
Pâ‰ˆ24Ã—14.6â‰ˆ350 W (15â€“20 A PSU ê¶Œì¥)

4) ë“œë¼ì´ë²„ ì„¤ì • ë° ì£¼ì˜
TB6600 ì „ë¥˜ ìŠ¤ìœ„ì¹˜ë¥¼ ëª¨í„° **ì •ê²©ì „ë¥˜(ë˜ëŠ” ê·¸ ì´í•˜)**ë¡œ ì„¤ì •í•˜ì„¸ìš”. (TB6600ì€ í†µìƒ ìµœëŒ€ ~4.5 A í”¼í¬ / ~3.5 A RMS ìˆ˜ì¤€ì´ë¯€ë¡œ, 4 Aê¸‰ ëª¨í„°ëŠ” ì‚´ì§ ë‚®ì¶° ì“°ëŠ” ê²Œ ì•ˆì „í•©ë‹ˆë‹¤.)

PSUëŠ” ë³‘ë ¬ ë°°ì„ ìœ¼ë¡œ TB6600 ë„¤ ê°œì— ê³µí†µ ê³µê¸‰(êµµì€ ë°°ì„ /ìŠ¤íƒ€ë°°ì„  ê¶Œì¥).

ë°©ì—´/ëƒ‰ê° í•„ìˆ˜(ë“œë¼ì´ë²„ íˆíŠ¸ì‹±í¬, íŒ¬).

EMI/ë…¸ì´ì¦ˆ ëŒ€ë¹„ë¡œ PSU-ë“œë¼ì´ë²„-ëª¨í„° ê°„ ê·¸ë¼ìš´ë“œ ì •ë¦¬, ì‹¤ë“œ ì¼€ì´ë¸”(í•„ìš”ì‹œ), ëª¨í„°-ë“œë¼ì´ë²„ ê°„ ë°°ì„  ì§§ê³  êµµê²Œ.

ì›í•˜ëŠ” ì •í™•í•œ ìˆ˜ì¹˜ë¥¼ ë½‘ì•„ë“œë¦¬ë ¤ë©´ **ëª¨í„° ë°ì´í„°ì‹œíŠ¸ì˜ ì •ê²©ì „ë¥˜(ìƒë‹¹)**ë§Œ ì•Œë ¤ì£¼ì‹œë©´ ë©ë‹ˆë‹¤. ìœ„ ê³µì‹ì— ê·¸ëŒ€ë¡œ ëŒ€ì…í•´ì„œ PSU ì „ë¥˜ì™€ ê¶Œì¥ ì „ì› ìš©ëŸ‰ì„ ë°”ë¡œ ê³„ì‚°í•´ ë“œë¦´ê²Œìš”.

ë‚˜ì˜ ë§:
raceback (most recent call last):
  File "/home/pi/Desktop/soldering/nema2.py", line 26, in <module>
    lgpio.gpio_claim_output(h, motor["step"])
  File "/usr/lib/python3/dist-packages/lgpio.py", line 781, in gpio_claim_output
    return _u2i(_lgpio._gpio_claim_output(handle&0xffff, lFlags, gpio, level))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3/dist-packages/lgpio.py", line 458, in _u2i
    raise error(error_text(v))
lgpio.error: 'GPIO busy'
ì˜¤ë¥˜ ì›ì¸ì°¾ì•„ì¤˜
ChatGPTì˜ ë§:
ì—ëŸ¬ ë©”ì‹œì§€ì˜ í•µì‹¬ì€ ë‹¤ìŒ ë¶€ë¶„ì´ì—ìš”:

lgpio.error: 'GPIO busy'
ì¦‰, lgpio.gpio_claim_output()ë¡œ ì§€ì •í•˜ë ¤ëŠ” GPIO í•€ì´ ì´ë¯¸ ì‚¬ìš© ì¤‘ì´ë¼ëŠ” ëœ»ì…ë‹ˆë‹¤. ì›ì¸ì„ ì •ë¦¬í•´ë³´ë©´:

ê°€ëŠ¥í•œ ì›ì¸
ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ì—ì„œ í•´ë‹¹ GPIOë¥¼ ì´ë¯¸ ì‚¬ìš© ì¤‘

ì˜ˆ: ê°™ì€ Python ì½”ë“œê°€ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì—¬ì „íˆ ì‹¤í–‰ ì¤‘ì´ê±°ë‚˜, ì´ì „ ì‹¤í–‰ì´ ì™„ì „íˆ ì¢…ë£Œë˜ì§€ ì•Šì€ ê²½ìš°.

pigpiod, gpio ê°™ì€ ë‹¤ë¥¸ ë“œë¼ì´ë²„/ë°ëª¬ì´ ì ìœ í•˜ê³  ìˆëŠ” ê²½ìš°ë„ ìˆìŒ.

ê°™ì€ ì½”ë“œì—ì„œ ì¤‘ë³µìœ¼ë¡œ claim

ì˜ˆ: ë£¨í”„ ì•ˆì—ì„œ gpio_claim_output()ì„ ë°˜ë³µ í˜¸ì¶œí•˜ê±°ë‚˜, í•œ í•€ì„ ì—¬ëŸ¬ ë²ˆ ì¡ìœ¼ë ¤ëŠ” ê²½ìš°.

ì˜¬ë°”ë¥¸ í•€ ë²ˆí˜¸ ë°©ì‹ ì‚¬ìš© ì•ˆ í•¨

Raspberry PiëŠ” BCM ë²ˆí˜¸ì™€ ë³´ë“œ ë¬¼ë¦¬ ë²ˆí˜¸ê°€ ë‹¤ë¦…ë‹ˆë‹¤. lgpioëŠ” ê¸°ë³¸ì ìœ¼ë¡œ BCM(GPIO) ë²ˆí˜¸ë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ í˜¼ë™ ì‹œ ì—ëŸ¬ê°€ ë‚  ìˆ˜ ìˆìŒ.

ì¢…ë£Œ ì‹œ í•€ í•´ì œê°€ ì•ˆ ë¨

í”„ë¡œê·¸ë¨ì´ ë¹„ì •ìƒ ì¢…ë£Œë˜ë©´ ì»¤ë„ì´ ì—¬ì „íˆ í•´ë‹¹ í•€ì„ â€œì‚¬ìš© ì¤‘â€ìœ¼ë¡œ ë‚¨ê²¨ë‘˜ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

í•´ê²° ë°©ë²•
í”„ë¡œì„¸ìŠ¤ í™•ì¸ & ì •ë¦¬

ps aux | grep python
ë‚¨ì•„ ìˆëŠ” Python í”„ë¡œì„¸ìŠ¤ë¥¼ killë¡œ ì¢…ë£Œí•˜ì„¸ìš”.

í•€ ë²ˆí˜¸ í™•ì¸

motor["step"]ì— ë“¤ì–´ê°€ëŠ” ê°’ì´ Raspberry Piì˜ BCM í•€ ë²ˆí˜¸ì¸ì§€ í™•ì¸í•˜ì„¸ìš”.

ì˜ˆ: GPIO17 â†’ ìˆ«ì 17 ì‚¬ìš©.

ì¤‘ë³µ claim ë°©ì§€

ì½”ë“œì—ì„œ ê°™ì€ í•€ì„ ì—¬ëŸ¬ ë²ˆ gpio_claim_output() í•˜ì§€ ì•Šì•˜ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.

ë£¨í”„ ë°”ê¹¥ì—ì„œ í•œ ë²ˆë§Œ claim í•˜ê³ , ë£¨í”„ ì•ˆì—ì„œëŠ” gpio_write()ë§Œ í•˜ë„ë¡ ê³ ì¹˜ì„¸ìš”.

lgpio.gpio_claim_output(h, motor["step"], 0)  # ì´ˆê¸° 1íšŒ claim
for i in range(100):
    lgpio.gpio_write(h, motor["step"], 1)
    lgpio.gpio_write(h, motor["step"], 0)
í”„ë¡œê·¸ë¨ ì¢…ë£Œ ì‹œ í•€ í•´ì œ

ì¢…ë£Œ ì „ì— ê¼­ lgpio.gpio_free(h, pin) ë˜ëŠ” lgpio.gpiochip_close(h) í˜¸ì¶œí•˜ì„¸ìš”.

ğŸ‘‰ ì§ˆë¬¸: í˜¹ì‹œ nema2.py ì½”ë“œì—ì„œ ê°™ì€ í•€ì„ ì—¬ëŸ¬ ë²ˆ claimí•˜ê³  ê³„ì‹ ê°€ìš”, ì•„ë‹ˆë©´ ì‹¤í–‰ ì¤‘ì¸ ë‹¤ë¥¸ ëª¨í„° ì œì–´ ì½”ë“œê°€ ë‚¨ì•„ ìˆì„ ìˆ˜ë„ ìˆëŠ”ë° í™•ì¸í•´ë“œë¦´ê¹Œìš”?

ë‚˜ì˜ ë§:
# stepper_4motor_scurve.py
import lgpio
import time
import math

# --- ëª¨í„° í•€ ì„¤ì • ---
step_pin_1, dir_pin_1 = 17, 27
step_pin_2, dir_pin_2 = 18, 23
step_pin_3, dir_pin_3 = 22, 24
step_pin_4, dir_pin_4 = 25, 5

MOTORS = [
    {"step": step_pin_1, "dir": dir_pin_1},
    {"step": step_pin_2, "dir": dir_pin_2},
    {"step": step_pin_3, "dir": dir_pin_3},
    {"step": step_pin_4, "dir": dir_pin_4},
]

# --- ìŠ¤í…ëª¨í„° íŒŒë¼ë¯¸í„° ---
STEPS_PER_REV = 200              # 1íšŒì „ = 200ìŠ¤í… (ë§ˆì´í¬ë¡œìŠ¤í… ì„¤ì •ì— ë§ê²Œ ìˆ˜ì •)
DEG_PER_STEP = 360.0 / STEPS_PER_REV

# --- GPIO ì´ˆê¸°í™” ---
h = lgpio.gpiochip_open(0)
for motor in MOTORS:
    lgpio.gpio_claim_output(h, motor["step"])
    lgpio.gpio_claim_output(h, motor["dir"])

# --- S-curve í”„ë¡œíŒŒì¼ ---
def s_curve_profile(steps: int):
    return [(1 - math.cos(math.pi * i / (steps - 1))) / 2 for i in range(steps)]

# --- ëª¨í„° ì œì–´ í•¨ìˆ˜ ---
def move_stepper(motor, current_angle, target_angle, duration=1.0):
    step_pin, dir_pin = motor["step"], motor["dir"]

    delta_angle = target_angle - current_angle
    steps_needed = int(abs(delta_angle) / DEG_PER_STEP)

    if steps_needed == 0:
        return target_angle

    # ë°©í–¥ ì„¤ì •
    direction = 1 if delta_angle > 0 else 0
    lgpio.gpio_write(h, dir_pin, direction)

    # S-curve ìƒì„±
    profile = s_curve_profile(steps_needed if steps_needed > 1 else 2)

    for _ in profile:
        lgpio.gpio_write(h, step_pin, 1)
        time.sleep(duration / steps_needed / 2)
        lgpio.gpio_write(h, step_pin, 0)
        time.sleep(duration / steps_needed / 2)

    return target_angle

# --- ë©”ì¸ ë£¨í”„ ---
if __name__ == "__main__":
    current_angles = [0, 0, 0, 0]  # 1~4ë²ˆ ëª¨í„° í˜„ì¬ ê°ë„

    try:
        while True:
            raw = input("ê°ë„ ì…ë ¥ (ì˜ˆ: 90 45 180 0): ")
            target_angles = list(map(int, raw.split()))

            if len(target_angles) != 4:
                print("âš ï¸ 1~4ë²ˆ ëª¨í„° ê°ë„ 4ê°œë¥¼ ì…ë ¥í•´ì•¼ í•©ë‹ˆë‹¤.")
                continue

            for i in range(4):
                print(f"ğŸ‘‰ {i+1}ë²ˆ ëª¨í„° {current_angles[i]}Â° â†’ {target_angles[i]}Â° ì´ë™ ì¤‘...")
                current_angles[i] = move_stepper(MOTORS[i], current_angles[i], target_angles[i], duration=2.0)

    except KeyboardInterrupt:
        print("\nì •ì§€: GPIO í•´ì œ")
        lgpio.gpiochip_close(h)
ì´ê±° ì˜¤ë¥˜ ì°¾ì•„ì¤˜
ChatGPTì˜ ë§:
ì¢‹ìŠµë‹ˆë‹¤ ğŸ‘ ì˜¬ë ¤ì£¼ì‹  stepper_4motor_scurve.py ì½”ë“œì—ì„œ GPIO busy ì˜¤ë¥˜ê°€ ë‚˜ëŠ” ì´ìœ ë¥¼ ì‚´í´ë³¼ê²Œìš”.

ğŸ” ë¬¸ì œ ì›ì¸
lgpio.gpio_claim_output() í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ëŠ” ë‹¤ìŒê³¼ ê°™ì•„ìš”:

lgpio.gpio_claim_output(handle, flags, gpio, level)
ì¦‰, **4ê°œì˜ ì¸ì(handle, flags, gpio ë²ˆí˜¸, ì´ˆê¸° ì¶œë ¥ ë ˆë²¨)**ë¥¼ ì¤˜ì•¼ í•˜ëŠ”ë°, ì½”ë“œì—ì„œëŠ”:

lgpio.gpio_claim_output(h, motor["step"])
lgpio.gpio_claim_output(h, motor["dir"])
ì²˜ëŸ¼ 2ê°œë§Œ ë„£ì—ˆì£ .
ì´ ê²½ìš° ë‚´ë¶€ì ìœ¼ë¡œ ì˜ëª»ëœ ì¸ìê°€ ë“¤ì–´ê°€ë©´ì„œ ë“œë¼ì´ë²„ê°€ í•€ì„ ì œëŒ€ë¡œ claim í•˜ì§€ ëª»í•˜ê³ , ê²°ê³¼ì ìœ¼ë¡œ GPIO busy ê°™ì€ ì˜¤ë¥˜ê°€ ë‚©ë‹ˆë‹¤.

âœ… ìˆ˜ì • ë°©ë²•
ê° í•€ claimí•  ë•Œ flagsì™€ ì´ˆê¸° ì¶œë ¥ ë ˆë²¨ì„ í•¨ê»˜ ì§€ì •í•´ ì£¼ì„¸ìš”. ë³´í†µ flagsëŠ” 0, levelì€ 0(LOW)ìœ¼ë¡œ ì‹œì‘í•˜ë©´ ë©ë‹ˆë‹¤.

ìˆ˜ì •ëœ ë¶€ë¶„
# --- GPIO ì´ˆê¸°í™” ---
h = lgpio.gpiochip_open(0)
for motor in MOTORS:
    lgpio.gpio_claim_output(h, 0, motor["step"], 0)  # step í•€ ì´ˆê¸°í™”
    lgpio.gpio_claim_output(h, 0, motor["dir"], 0)   # dir í•€ ì´ˆê¸°í™”
ğŸ”§ ì¶”ê°€ ê¶Œì¥ ì‚¬í•­
ì½”ë“œ ì¢…ë£Œ ì‹œ í•€ í•´ì œ
í˜„ì¬ëŠ” gpiochip_close(h)ë§Œ í˜¸ì¶œí•˜ëŠ”ë°, ê°œë³„ í•€ì„ í•´ì œí•˜ë ¤ë©´ lgpio.gpio_free(h, pin)ì„ í˜¸ì¶œí•˜ëŠ” ê²ƒì´ ë” ì•ˆì „í•©ë‹ˆë‹¤.

for motor in MOTORS:
    lgpio.gpio_free(h, motor["step"])
    lgpio.gpio_free(h, motor["dir"])
lgpio.gpiochip_close(h)
ë™ì‹œ êµ¬ë™ ê³ ë ¤
ì§€ê¸ˆ êµ¬ì¡°ëŠ” 1ë²ˆ â†’ 2ë²ˆ â†’ 3ë²ˆ â†’ 4ë²ˆ ëª¨í„° ìˆœì°¨ ì‹¤í–‰ì´ì—ìš”. 4ê°œë¥¼ ë™ì‹œì— êµ¬ë™í•˜ë ¤ë©´ threadingì´ë‚˜ asyncioë¥¼ ì¨ì•¼ í•©ë‹ˆë‹¤.

S-curve í”„ë¡œíŒŒì¼ í™œìš©
í˜„ì¬ëŠ” í”„ë¡œíŒŒì¼ ê°’ì„ ê³„ì‚°í•˜ì§€ë§Œ, ì‹¤ì œë¡œ delayì— ë°˜ì˜í•˜ì§€ ì•Šê³  duration / steps_neededë¡œë§Œ ì“°ê³  ìˆì–´ìš”.
ì›ë˜ ì˜ë„ë¼ë©´ profile ê°’(ê°€ì†/ê°ì† ë¹„ìœ¨)ì„ delay ê³„ì‚°ì— ê³±í•´ì£¼ì–´ì•¼ í•©ë‹ˆë‹¤.

ğŸ‘‰ ì •ë¦¬í•˜ë©´, ì˜¤ë¥˜ì˜ ì§ì ‘ì ì¸ ì›ì¸ì€ gpio_claim_output() ì¸ìë¥¼ ì˜ëª» ì¤€ ê²ƒì´ê³ , ì•„ë˜ì²˜ëŸ¼ ê³ ì¹˜ë©´ í•´ê²°ë  ê²ë‹ˆë‹¤:

lgpio.gpio_claim_output(h, 0, motor["step"], 0)
lgpio.gpio_claim_output(h, 0, motor["dir"], 0)
ì›í•˜ì‹œë©´ ì œê°€ S-curve í”„ë¡œíŒŒì¼ê¹Œì§€ ì‹¤ì œ ê°€ì†/ê°ì†ì— ë°˜ì˜ë˜ë„ë¡ ì½”ë“œ ë¦¬íŒ©í† ë§ë„ í•´ë“œë¦´ê¹Œìš”?

ë‚˜ì˜ ë§:
ë¦¬í™í† ë§
ChatGPTì˜ ë§:
ì¢‹ìŠµë‹ˆë‹¤ ğŸ‘ ì˜¬ë ¤ì£¼ì‹  ì½”ë“œë¥¼ ë¦¬íŒ©í† ë§í•´ì„œ

gpio_claim_output í˜¸ì¶œì„ ì˜¬ë°”ë¥´ê²Œ ìˆ˜ì •

S-curve í”„ë¡œíŒŒì¼ì„ ì‹¤ì œ ì†ë„(ë”œë ˆì´)ì— ë°˜ì˜

ì¢…ë£Œ ì‹œ í•€ í•´ì œ ì²˜ë¦¬

ê¹Œì§€ ë°˜ì˜í•œ ë²„ì „ì„ ë“œë¦´ê²Œìš”.

âœ… ë¦¬íŒ©í† ë§ëœ ì½”ë“œ
# stepper_4motor_scurve_refactored.py
import lgpio
import time
import math

# --- ëª¨í„° í•€ ì„¤ì • (BCM ë²ˆí˜¸) ---
step_pin_1, dir_pin_1 = 17, 27
step_pin_2, dir_pin_2 = 18, 23
step_pin_3, dir_pin_3 = 22, 24
step_pin_4, dir_pin_4 = 25, 5

MOTORS = [
    {"step": step_pin_1, "dir": dir_pin_1},
    {"step": step_pin_2, "dir": dir_pin_2},
    {"step": step_pin_3, "dir": dir_pin_3},
    {"step": step_pin_4, "dir": dir_pin_4},
]

# --- ìŠ¤í…ëª¨í„° íŒŒë¼ë¯¸í„° ---
STEPS_PER_REV = 200              # 1íšŒì „ = 200ìŠ¤í… (ë§ˆì´í¬ë¡œìŠ¤í…ì— ë§ê²Œ ìˆ˜ì •)
DEG_PER_STEP = 360.0 / STEPS_PER_REV

# --- GPIO ì´ˆê¸°í™” ---
h = lgpio.gpiochip_open(0)
for motor in MOTORS:
    lgpio.gpio_claim_output(h, 0, motor["step"], 0)  # step í•€ LOWë¡œ ì´ˆê¸°í™”
    lgpio.gpio_claim_output(h, 0, motor["dir"], 0)   # dir í•€ LOWë¡œ ì´ˆê¸°í™”

# --- S-curve í”„ë¡œíŒŒì¼ ìƒì„± ---
def s_curve_profile(steps: int):
    """
    steps ê¸¸ì´ì˜ S-curve ê°€ì†/ê°ì† ë¹„ìœ¨ ë°°ì—´ì„ ìƒì„±.
    (cosine ê¸°ë°˜: 0 â†’ 1 â†’ 0 ì†ë„ ë³€í™”)
    """
    return [(1 - math.cos(math.pi * i / (steps - 1))) / 2 for i in range(steps)]

# --- ëª¨í„° ì œì–´ í•¨ìˆ˜ ---
def move_stepper(motor, current_angle, target_angle, duration=1.0):
    step_pin, dir_pin = motor["step"], motor["dir"]

    delta_angle = target_angle - current_angle
    steps_needed = int(abs(delta_angle) / DEG_PER_STEP)

    if steps_needed == 0:
        return target_angle

    # ë°©í–¥ ì„¤ì •
    direction = 1 if delta_angle > 0 else 0
    lgpio.gpio_write(h, dir_pin, direction)

    # S-curve í”„ë¡œíŒŒì¼ ìƒì„±
    profile = s_curve_profile(steps_needed if steps_needed > 1 else 2)

    # ì „ì²´ ì´ë™ ì‹œê°„ì„ profileì— ë”°ë¼ ë¶„ë°°
    for weight in profile:
        delay = (duration / steps_needed) * (1 + (1 - weight))  # ê°€ì†/ê°ì† ë°˜ì˜
        lgpio.gpio_write(h, step_pin, 1)
        time.sleep(delay / 2)
        lgpio.gpio_write(h, step_pin, 0)
        time.sleep(delay / 2)

    return target_angle

# --- ë©”ì¸ ë£¨í”„ ---
if __name__ == "__main__":
    current_angles = [0, 0, 0, 0]  # 1~4ë²ˆ ëª¨í„° í˜„ì¬ ê°ë„

    try:
        while True:
            raw = input("ê°ë„ ì…ë ¥ (ì˜ˆ: 90 45 180 0): ")
            target_angles = list(map(int, raw.split()))

            if len(target_angles) != 4:
                print("âš ï¸ 1~4ë²ˆ ëª¨í„° ê°ë„ 4ê°œë¥¼ ì…ë ¥í•´ì•¼ í•©ë‹ˆë‹¤.")
                continue

            for i in range(4):
                print(f"ğŸ‘‰ {i+1}ë²ˆ ëª¨í„° {current_angles[i]}Â° â†’ {target_angles[i]}Â° ì´ë™ ì¤‘...")
                current_angles[i] = move_stepper(MOTORS[i], current_angles[i], target_angles[i], duration=2.0)

    except KeyboardInterrupt:
        print("\nì •ì§€: GPIO í•´ì œ")
        for motor in MOTORS:
            lgpio.gpio_free(h, motor["step"])
            lgpio.gpio_free(h, motor["dir"])
        lgpio.gpiochip_close(h)
ğŸ”‘ ë³€ê²½ ì‚¬í•­ ìš”ì•½
gpio_claim_output(h, 0, pin, 0) â†’ ì˜¬ë°”ë¥¸ í˜¸ì¶œë¡œ ìˆ˜ì •.

s_curve_profile() ë°˜í™˜ê°’ì„ ë”œë ˆì´ ê°€ì¤‘ì¹˜ë¡œ ë°˜ì˜.

ì‹œì‘ì€ ê¸¸ê²Œ(ëŠë¦¬ê²Œ), ì¤‘ê°„ì€ ì§§ê²Œ(ë¹ ë¥´ê²Œ), ëì€ ë‹¤ì‹œ ê¸¸ê²Œ â†’ ë¶€ë“œëŸ¬ìš´ ê°€ê°ì†.

ì¢…ë£Œ ì‹œ gpio_free() ì¶”ê°€í•˜ì—¬ GPIO í•€ í•´ì œ í™•ì‹¤íˆ ì²˜ë¦¬.

ğŸ‘‰ ì§€ê¸ˆ êµ¬ì¡°ëŠ” ì—¬ì „íˆ 4ê°œ ëª¨í„°ë¥¼ ìˆœì°¨ ì œì–´í•©ë‹ˆë‹¤.
ë§Œì•½ 4ê°œ ëª¨í„°ë¥¼ ë™ì‹œì— S-curveë¡œ êµ¬ë™í•˜ê³  ì‹¶ìœ¼ì„¸ìš”, ì•„ë‹ˆë©´ ì§€ê¸ˆì²˜ëŸ¼ ê°œë³„ì ìœ¼ë¡œë§Œ ì›€ì§ì—¬ë„ ê´œì°®ìœ¼ì„¸ìš”?

ë‚˜ì˜ ë§:
Traceback (most recent call last): File "/home/pi/Desktop/soldering/nema.py", line 85, in lgpio.gpio_claim_output(h, dir_pin, 0) File "/usr/lib/python3/dist-packages/lgpio.py", line 781, in gpio_claim_output return _u2i(_lgpio._gpio_claim_output(handle&0xffff, lFlags, gpio, level)) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File "/usr/lib/python3/dist-packages/lgpio.py", line 458, in _u2i raise error(error_text(v)) lgpio.error: 'GPIO busy'
ì´ë ‡ê²Œ ì˜¤ë¥˜ëœ¨ëŠ”ë° ì›ì¸ ì°¾ì•„ë´
ChatGPTì˜ ë§:
ë„¤, ì´ë²ˆ ì—ëŸ¬ ë¡œê·¸ë¥¼ ë³´ë©´ í•µì‹¬ì€ ë‹¤ì‹œ lgpio.error: 'GPIO busy' ì…ë‹ˆë‹¤.
ê·¸ëŸ°ë° ì´ë²ˆì—ëŠ” í•¨ìˆ˜ í˜¸ì¶œì´ ì´ë ‡ê²Œ ì°í˜”ë„¤ìš”:

lgpio.gpio_claim_output(h, dir_pin, 0)
ğŸ” ë¬¸ì œ í¬ì¸íŠ¸
gpio_claim_output()ì˜ ì˜¬ë°”ë¥¸ ì‹œê·¸ë‹ˆì²˜ëŠ”:

lgpio.gpio_claim_output(handle, flags, gpio, level)
ì¦‰, ì¸ì 4ê°œê°€ í•„ìš”í•©ë‹ˆë‹¤:

handle â†’ gpiochip_open()ìœ¼ë¡œ ì–»ì€ í•¸ë“¤

flags â†’ ë³´í†µ 0

gpio â†’ BCM GPIO ë²ˆí˜¸

level â†’ ì´ˆê¸° ì¶œë ¥ê°’ (0 or 1)

ê·¸ëŸ°ë° í˜„ì¬ í˜¸ì¶œì€:

lgpio.gpio_claim_output(h, dir_pin, 0)
ğŸ‘‰ ì—¬ê¸°ì„œ dir_pinì´ flags ìë¦¬ì— ë“¤ì–´ê°€ ë²„ë ¸ê³ ,
ê·¸ ë’¤ì˜ 0ì´ gpio ë²ˆí˜¸ ìë¦¬ì— ë“¤ì–´ê°€ ë²„ë¦° ê²ƒì´ì—ìš”.
ì¦‰, ì™„ì „íˆ ì˜ëª»ëœ ìˆœì„œë¼ì„œ ë“œë¼ì´ë²„ê°€ ë§ë„ ì•ˆ ë˜ëŠ” í•€ì„ claimí•˜ë ¤ê³  í•˜ë‹¤ê°€ "ì´ë¯¸ ì‚¬ìš© ì¤‘" ì—ëŸ¬ë¥¼ ë˜ì§„ ê²ë‹ˆë‹¤.

âœ… í•´ê²° ë°©ë²•
ê³ ì³ì•¼ í•  ì˜¬ë°”ë¥¸ í˜¸ì¶œ ì˜ˆì‹œëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

lgpio.gpio_claim_output(h, 0, dir_pin, 0)
ì¦‰, í•­ìƒ 0 (flags) â†’ í•€ ë²ˆí˜¸ â†’ ì´ˆê¸° ì¶œë ¥ ë ˆë²¨ ìˆœì„œë¡œ ë„£ì–´ì•¼ í•©ë‹ˆë‹¤.

ğŸš‘ ì¶”ê°€ ì ê²€
í˜¹ì‹œ ì½”ë“œ ì¼ë¶€ëŠ” lgpio.gpio_claim_output(h, motor["step"]) ì´ëŸ° ì‹ìœ¼ë¡œ ì˜ëª» ì¨ë†“ìœ¼ì…¨ì„ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.
ì „ë¶€ 4ì¸ì ë°©ì‹ìœ¼ë¡œ ë°”ê¿”ì•¼ í•©ë‹ˆë‹¤.

í”„ë¡œê·¸ë¨ì„ ê°•ì œ ì¢…ë£Œ(Ctrl+C)í•œ í›„ì—ë„ GPIOê°€ "busy"ë¡œ ë‚¨ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ´ ë•:

sudo reboot
í•˜ê±°ë‚˜, ì½”ë“œì—ì„œ lgpio.gpio_free(h, pin) â†’ lgpio.gpiochip_close(h)ë¥¼ ê¼­ ì‹¤í–‰í•´ ì£¼ì„¸ìš”.

ğŸ‘‰ ì§ˆë¬¸: ì§€ê¸ˆì€ ëª¨í„° 1ê°œ ì œì–´ ì¤‘ì¸ë°ë„ GPIO busyê°€ ëœ¨ë‚˜ìš”, ì•„ë‹ˆë©´ ì—¬ëŸ¬ ëª¨í„° í•€ì„ ë™ì‹œì— claimí•  ë•Œ ì¶©ëŒì´ ìƒê¸°ëŠ” ê±´ê°€ìš”?

ë‚˜ì˜ ë§:
ìˆœì°¨ì ìœ¼ë¡œ ê°ë„ë¥¼ ë„£ê³  ìˆœì°¨ì ìœ¼ë¡œ ì‹¤í–‰í•˜ê³  ì‹¶ë‹¤ ì½”ë“œ ìˆ˜ì •í•´ë¼
ChatGPTì˜ ë§:

59s ë™ì•ˆ ìƒê°í•¨
ì¢‹ì•„ìš”! â€œê°ë„ë¥¼ í•˜ë‚˜ì”© ì…ë ¥í•˜ë©´ ê·¸ ëª¨í„°ê°€ ë°”ë¡œ ì›€ì§ì´ê³ , ë‹¤ìŒ ëª¨í„°ë¡œ ë„˜ì–´ê°€ëŠ”â€ ìˆœì°¨ ì…ë ¥ â†’ ìˆœì°¨ ì‹¤í–‰ í˜•íƒœë¡œ ë¦¬íŒ©í† ë§í–ˆì–´ìš”.
gpio_claim_output ì¸ìë„ ì˜¬ë°”ë¥¸ ìˆœì„œ(í•¸ë“¤, í”Œë˜ê·¸, í•€, ì´ˆê¸°ë ˆë²¨)ë¡œ ìˆ˜ì •í–ˆê³ , S-curveë¥¼ ì‹¤ì œ ì†ë„ ê°€ì¤‘ì¹˜ë¡œ ì ìš©í•´ ì „ì²´ ì´ë™ì‹œê°„ì´ durationì— ë§ê²Œ ë¶„ë°°ë˜ë„ë¡ í–ˆìŠµë‹ˆë‹¤. ì¢…ë£Œ ì‹œì—ëŠ” í•€ë„ í™•ì‹¤íˆ í•´ì œí•©ë‹ˆë‹¤.

# stepper_4motor_scurve_sequential.py
import lgpio
import time
import math

# --- ì„¤ì • ---
# BCM í•€ ë²ˆí˜¸ ì‚¬ìš©
step_pin_1, dir_pin_1 = 17, 27
step_pin_2, dir_pin_2 = 18, 23
step_pin_3, dir_pin_3 = 22, 24
step_pin_4, dir_pin_4 = 25, 5

MOTORS = [
    {"step": step_pin_1, "dir": dir_pin_1, "name": "ëª¨í„°1"},
    {"step": step_pin_2, "dir": dir_pin_2, "name": "ëª¨í„°2"},
    {"step": step_pin_3, "dir": dir_pin_3, "name": "ëª¨í„°3"},
    {"step": step_pin_4, "dir": dir_pin_4, "name": "ëª¨í„°4"},
]

# ë§ˆì´í¬ë¡œìŠ¤í… ì„¤ì •ì— ë§ê²Œ ë³€ê²½ (ì˜ˆ: TB6600ì—ì„œ 1/8 ì´ë©´ 200*8)
MICROSTEP = 1
STEPS_PER_REV = 200 * MICROSTEP
DEG_PER_STEP = 360.0 / STEPS_PER_REV

# í•˜ë“œì›¨ì–´ íƒ€ì´ë°(ë³´ìˆ˜ì )
DIR_SETUP_S = 0.000010     # DIR ë°”ê¾¼ ë’¤ STEP ì£¼ê¸°ì „ ìµœì†Œ ì¤€ë¹„ì‹œê°„(10us)
STEP_PULSE_MIN_S = 0.000010  # STEP High/Low ìµœì†Œ í„ìŠ¤(10us)

def gpio_init():
    h = lgpio.gpiochip_open(0)
    for m in MOTORS:
        lgpio.gpio_claim_output(h, 0, m["step"], 0)  # (handle, flags, gpio, level)
        lgpio.gpio_claim_output(h, 0, m["dir"], 0)
    return h

def gpio_cleanup(h):
    # ê°œë³„ í•€ í•´ì œ í›„ ì¹© í•¸ë“¤ ë‹«ê¸°
    for m in MOTORS:
        try:
            lgpio.gpio_free(h, m["step"])
            lgpio.gpio_free(h, m["dir"])
        except Exception:
            pass
    try:
        lgpio.gpiochip_close(h)
    except Exception:
        pass

# S-curve: 0â†’1ë¡œ ì˜¬ë¼ê°€ëŠ” ì½”ì‚¬ì¸ ê¸°ë°˜ í”„ë¡œíŒŒì¼
def s_curve_profile(steps: int):
    if steps <= 1:
        return [1.0]
    return [(1 - math.cos(math.pi * i / (steps - 1))) / 2 for i in range(steps)]

def move_stepper(h, motor, current_angle, target_angle, duration=1.0):
    step_pin, dir_pin = motor["step"], motor["dir"]

    delta_angle = target_angle - current_angle
    steps_needed = int(round(abs(delta_angle) / DEG_PER_STEP))

    if steps_needed == 0:
        return target_angle

    # ë°©í–¥ ì„¤ì • (DIR setup time ì¤€ìˆ˜)
    direction = 1 if delta_angle > 0 else 0
    lgpio.gpio_write(h, dir_pin, direction)
    time.sleep(DIR_SETUP_S)

    # ì†ë„ ê°€ì¤‘ì¹˜ ê³„ì‚° (S-curve) â€” ìµœì†Œ ì†ë„ ë°”ë‹¥ê°’ EPSë¡œ ë¬´í•œëŒ€ ì£¼ê¸° ë°©ì§€
    EPS = 0.15  # 0.0~1.0 ì‚¬ì´, í´ìˆ˜ë¡ ì‹œë™/ì •ì§€ êµ¬ê°„ì´ ë¹ ë¦„
    base_profile = s_curve_profile(steps_needed)
    speed_weights = [EPS + (1.0 - EPS) * v for v in base_profile]  # ëª¨ë‘ > 0

    # ì´ durationì„ ê° ìŠ¤í… ì£¼ê¸°ë¡œ ì •í™•íˆ ë¶„ë°°:
    # period_i âˆ 1 / speed_i  ->  sum_i(period_i) = duration
    inv_sum = sum(1.0 / w for w in speed_weights)
    k = duration / inv_sum

    for w in speed_weights:
        period = max(k / w, STEP_PULSE_MIN_S * 2)   # í•˜í”„ í„ìŠ¤ 2ë°° ì´ìƒ í™•ë³´
        high_t = max(STEP_PULSE_MIN_S, period / 2)  # í•˜ì´ í„ìŠ¤
        low_t  = max(STEP_PULSE_MIN_S, period - high_t)

        lgpio.gpio_write(h, step_pin, 1)
        time.sleep(high_t)
        lgpio.gpio_write(h, step_pin, 0)
        time.sleep(low_t)

    return target_angle

def main():
    h = gpio_init()
    current_angles = [0.0, 0.0, 0.0, 0.0]

    print("ìˆœì°¨ ì…ë ¥ ëª¨ë“œ: ëª¨í„°1 â†’ ëª¨í„°2 â†’ ëª¨í„°3 â†’ ëª¨í„°4 ìˆœì„œë¡œ ê°ë„ ì…ë ¥ í›„ ì¦‰ì‹œ ë™ì‘í•©ë‹ˆë‹¤.")
    print("ì…ë ¥ ì˜ˆ) 90   (ì—”í„°ë§Œ ì¹˜ë©´ ê±´ë„ˆëœ€, q ì…ë ¥ ì‹œ ì¢…ë£Œ)")
    try:
        while True:
            for i, m in enumerate(MOTORS):
                raw = input(f"{m['name']} ëª©í‘œ ê°ë„? (í˜„ì¬ {current_angles[i]:.1f}Â°) : ").strip()
                if raw.lower() in ("q", "quit", "exit"):
                    raise KeyboardInterrupt
                if raw == "":
                    print(f" - {m['name']} ê±´ë„ˆëœ€")
                    continue
                try:
                    target = float(raw)
                except ValueError:
                    print("âš ï¸ ìˆ«ìë¥¼ ì…ë ¥í•˜ì„¸ìš”. (ì˜ˆ: 90, -45)")
                    continue

                print(f"ğŸ‘‰ {m['name']} {current_angles[i]:.1f}Â° â†’ {target:.1f}Â° ì´ë™ ì¤‘...")
                # í•„ìš” ì‹œ ëª¨í„°ë³„ duration ë‹¤ë¥´ê²Œ ì£¼ê³  ì‹¶ìœ¼ë©´ ì¸ìë¡œ ì „ë‹¬
                current_angles[i] = move_stepper(h, m, current_angles[i], target, duration=2.0)
                print(f"âœ… {m['name']} ì™„ë£Œ: í˜„ì¬ {current_angles[i]:.1f}Â°")

    except KeyboardInterrupt:
        print("\nì •ì§€: GPIO í•´ì œ ì¤‘...")
    finally:
        gpio_cleanup(h)
        print("GPIO í•´ì œ ì™„ë£Œ. í”„ë¡œê·¸ë¨ ì¢…ë£Œ.")

if __name__ == "__main__":
    main()
í¬ì¸íŠ¸
ìˆœì°¨ ì…ë ¥ â†’ ì¦‰ì‹œ ì‹¤í–‰: ëª¨í„°1 ê°ë„ ì…ë ¥ â†’ ì‹¤í–‰ â†’ ëª¨í„°2 ì…ë ¥ â†’ ì‹¤í–‰ â€¦ ë°˜ë³µ.

gpio_claim_output(h, 0, pin, 0)ì²˜ëŸ¼ ì¸ì ìˆœì„œë¥¼ ë°˜ë“œì‹œ ì§€ì¼°ìŠµë‹ˆë‹¤.

S-curve ì†ë„ ê°€ì¤‘ì¹˜ë¡œ ê° ìŠ¤í… ì£¼ê¸°ë¥¼ ê³„ì‚°í•´ **ì´ ì‹œê°„(duration)**ì´ ì •í™•íˆ ë§ë„ë¡ ë¶„ë°°í•©ë‹ˆë‹¤.

TB6600ì˜ DIR setup/STEP ìµœì†Œ í„ìŠ¤ë¥¼ ê³ ë ¤í•´ ë§ˆì´í¬ë¡œì´ˆ ë‹¨ìœ„ ì•ˆì „ ì—¬ìœ ë¥¼ ì¤¬ìŠµë‹ˆë‹¤.

ì¢…ë£Œ/ì˜ˆì™¸ ì‹œ ëª¨ë“  í•€ì„ gpio_free í›„ gpiochip_closeë¡œ ì •ë¦¬.

í•„ìš”í•˜ë©´ â€œ4ê°œ ëª¨í„°ë¥¼ ë™ì‹œì—â€ ê°™ì€ ë™ì‘(ìŠ¤ë ˆë“œ ê¸°ë°˜ ë³‘ë ¬ êµ¬ë™) ë²„ì „ë„ ë§Œë“¤ì–´ ë“œë¦´ê²Œìš”.

ë‚˜ì˜ ë§:
step_pin_1, dir_pin_1 = 17, 18
step_pin_2, dir_pin_2 = 27, 22
step_pin_3, dir_pin_3 = 23, 24
step_pin_4, dir_pin_4 = 10, 9
í•€ë²ˆí˜¸ ì´ê±¸ë¡œ ë³€ê²½
ChatGPTì˜ ë§:
ì•Œê² ìŠµë‹ˆë‹¤ ğŸ‘ ìš”ì²­í•˜ì‹  ìƒˆë¡œìš´ í•€ ë²ˆí˜¸ë¡œ ì½”ë“œë¥¼ ìˆ˜ì •í•´ë“œë¦´ê²Œìš”.

âœ… ìˆ˜ì •ëœ í•€ ë§¤í•‘
# --- ëª¨í„° í•€ ì„¤ì • (BCM ë²ˆí˜¸) ---
step_pin_1, dir_pin_1 = 17, 18
step_pin_2, dir_pin_2 = 27, 22
step_pin_3, dir_pin_3 = 23, 24
step_pin_4, dir_pin_4 = 10, 9

MOTORS = [
    {"step": step_pin_1, "dir": dir_pin_1, "name": "ëª¨í„°1"},
    {"step": step_pin_2, "dir": dir_pin_2, "name": "ëª¨í„°2"},
    {"step": step_pin_3, "dir": dir_pin_3, "name": "ëª¨í„°3"},
    {"step": step_pin_4, "dir": dir_pin_4, "name": "ëª¨í„°4"},
]
ğŸ”§ ì „ì²´ ì½”ë“œì— ì ìš©í•œ ë²„ì „
ì•„ë˜ëŠ” ì•ì„œ ë“œë¦° ìˆœì°¨ ì…ë ¥/ìˆœì°¨ ì‹¤í–‰ ì½”ë“œì—ì„œ í•€ ë²ˆí˜¸ë§Œ êµì²´í•œ ê²ƒì…ë‹ˆë‹¤.

# stepper_4motor_scurve_sequential.py
import lgpio
import time
import math

# --- ëª¨í„° í•€ ì„¤ì • (BCM ë²ˆí˜¸) ---
step_pin_1, dir_pin_1 = 17, 18
step_pin_2, dir_pin_2 = 27, 22
step_pin_3, dir_pin_3 = 23, 24
step_pin_4, dir_pin_4 = 10, 9

MOTORS = [
    {"step": step_pin_1, "dir": dir_pin_1, "name": "ëª¨í„°1"},
    {"step": step_pin_2, "dir": dir_pin_2, "name": "ëª¨í„°2"},
    {"step": step_pin_3, "dir": dir_pin_3, "name": "ëª¨í„°3"},
    {"step": step_pin_4, "dir": dir_pin_4, "name": "ëª¨í„°4"},
]

# ë§ˆì´í¬ë¡œìŠ¤í… ì„¤ì • (TB6600 DIP ìŠ¤ìœ„ì¹˜ì— ë§ê²Œ ìˆ˜ì •)
MICROSTEP = 1
STEPS_PER_REV = 200 * MICROSTEP
DEG_PER_STEP = 360.0 / STEPS_PER_REV

# í•˜ë“œì›¨ì–´ íƒ€ì´ë°
DIR_SETUP_S = 0.000010       # 10us
STEP_PULSE_MIN_S = 0.000010  # 10us

def gpio_init():
    h = lgpio.gpiochip_open(0)
    for m in MOTORS:
        lgpio.gpio_claim_output(h, 0, m["step"], 0)
        lgpio.gpio_claim_output(h, 0, m["dir"], 0)
    return h

def gpio_cleanup(h):
    for m in MOTORS:
        try:
            lgpio.gpio_free(h, m["step"])
            lgpio.gpio_free(h, m["dir"])
        except Exception:
            pass
    lgpio.gpiochip_close(h)

def s_curve_profile(steps: int):
    if steps <= 1:
        return [1.0]
    return [(1 - math.cos(math.pi * i / (steps - 1))) / 2 for i in range(steps)]

def move_stepper(h, motor, current_angle, target_angle, duration=1.0):
    step_pin, dir_pin = motor["step"], motor["dir"]

    delta_angle = target_angle - current_angle
    steps_needed = int(round(abs(delta_angle) / DEG_PER_STEP))
    if steps_needed == 0:
        return target_angle

    direction = 1 if delta_angle > 0 else 0
    lgpio.gpio_write(h, dir_pin, direction)
    time.sleep(DIR_SETUP_S)

    EPS = 0.15
    base_profile = s_curve_profile(steps_needed)
    speed_weights = [EPS + (1.0 - EPS) * v for v in base_profile]

    inv_sum = sum(1.0 / w for w in speed_weights)
    k = duration / inv_sum

    for w in speed_weights:
        period = max(k / w, STEP_PULSE_MIN_S * 2)
        high_t = max(STEP_PULSE_MIN_S, period / 2)
        low_t = max(STEP_PULSE_MIN_S, period - high_t)

        lgpio.gpio_write(h, step_pin, 1)
        time.sleep(high_t)
        lgpio.gpio_write(h, step_pin, 0)
        time.sleep(low_t)

    return target_angle

def main():
    h = gpio_init()
    current_angles = [0.0, 0.0, 0.0, 0.0]

    print("ìˆœì°¨ ì…ë ¥ ëª¨ë“œ: ëª¨í„°1 â†’ ëª¨í„°2 â†’ ëª¨í„°3 â†’ ëª¨í„°4 ìˆœì„œë¡œ ê°ë„ ì…ë ¥ í›„ ì¦‰ì‹œ ë™ì‘í•©ë‹ˆë‹¤.")
    print("ì…ë ¥ ì˜ˆ) 90   (ì—”í„°ë§Œ ì¹˜ë©´ ê±´ë„ˆëœ€, q ì…ë ¥ ì‹œ ì¢…ë£Œ)")
    try:
        while True:
            for i, m in enumerate(MOTORS):
                raw = input(f"{m['name']} ëª©í‘œ ê°ë„? (í˜„ì¬ {current_angles[i]:.1f}Â°) : ").strip()
                if raw.lower() in ("q", "quit", "exit"):
                    raise KeyboardInterrupt
                if raw == "":
                    print(f" - {m['name']} ê±´ë„ˆëœ€")
                    continue
                try:
                    target = float(raw)
                except ValueError:
                    print("âš ï¸ ìˆ«ìë¥¼ ì…ë ¥í•˜ì„¸ìš”. (ì˜ˆ: 90, -45)")
                    continue

                print(f"ğŸ‘‰ {m['name']} {current_angles[i]:.1f}Â° â†’ {target:.1f}Â° ì´ë™ ì¤‘...")
                current_angles[i] = move_stepper(h, m, current_angles[i], target, duration=2.0)
                print(f"âœ… {m['name']} ì™„ë£Œ: í˜„ì¬ {current_angles[i]:.1f}Â°")

    except KeyboardInterrupt:
        print("\nì •ì§€: GPIO í•´ì œ ì¤‘...")
    finally:
        gpio_cleanup(h)
        print("GPIO í•´ì œ ì™„ë£Œ. í”„ë¡œê·¸ë¨ ì¢…ë£Œ.")

if __name__ == "__main__":
    main()
ğŸ‘‰ ì´ë ‡ê²Œ í•˜ë©´ ìƒˆë¡œìš´ í•€ ë²ˆí˜¸ì— ë§ê²Œ ëª¨í„° 4ê°œë¥¼ ìˆœì°¨ ì…ë ¥Â·ìˆœì°¨ ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì›í•˜ì‹œë©´ ì œê°€ **â€œë™ì‹œì— 4ê°œ ëª¨í„°ë¥¼ ë³‘ë ¬ë¡œ ì‹¤í–‰â€**í•˜ëŠ” ì½”ë“œ ë²„ì „ë„ ë§Œë“¤ì–´ë“œë¦´ê¹Œìš”?

ë‚˜ì˜ ë§:
ëª¨í„°ë¥¼ í•˜ë‚˜ëŒë¦¬ê³  ë„ê³  í•˜ë‚˜ëŒë¦¬ê³  ë„ê³  í•˜ì
ChatGPTì˜ ë§:
ì¢‹ìŠµë‹ˆë‹¤ ğŸ‘ ë§ì”€í•˜ì‹  ê±´ ëª¨í„°ë¥¼ í•œ ë²ˆì”© ëŒë¦¬ê³  â†’ ë©ˆì¶”ê³  â†’ ë‹¤ìŒ ëª¨í„° ëŒë¦¬ê³  â†’ ë©ˆì¶”ê³ â€¦ ì´ëŸ° â€œìˆœì°¨ êµ¬ë™ + ì¤‘ê°„ì— ë„ê¸°(Idle)â€ ë™ì‘ì´ë„¤ìš”.
ê¸°ì¡´ ì½”ë“œë¥¼ ì¡°ê¸ˆ ë‹¨ìˆœí™”í•´ì„œ ê° ëª¨í„°ë¥¼ ìˆœì„œëŒ€ë¡œ ëŒë¦¬ê³ , ëŒë¦° ë’¤ì—ëŠ” ë„ë„ë¡(step ì‹ í˜¸ ì—†ìŒ + dirë„ LOW ìœ ì§€) ìˆ˜ì •í•´ë“œë¦¬ê² ìŠµë‹ˆë‹¤.

âœ… ë¦¬íŒ©í† ë§ ì½”ë“œ (ëª¨í„° ìˆœì°¨ êµ¬ë™ + ë„ê¸°)
# stepper_4motor_turn_off_after_each.py
import lgpio
import time
import math

# --- ëª¨í„° í•€ ì„¤ì • (BCM ë²ˆí˜¸) ---
step_pin_1, dir_pin_1 = 17, 18
step_pin_2, dir_pin_2 = 27, 22
step_pin_3, dir_pin_3 = 23, 24
step_pin_4, dir_pin_4 = 10, 9

MOTORS = [
    {"step": step_pin_1, "dir": dir_pin_1, "name": "ëª¨í„°1"},
    {"step": step_pin_2, "dir": dir_pin_2, "name": "ëª¨í„°2"},
    {"step": step_pin_3, "dir": dir_pin_3, "name": "ëª¨í„°3"},
    {"step": step_pin_4, "dir": dir_pin_4, "name": "ëª¨í„°4"},
]

# --- ìŠ¤í…ëª¨í„° íŒŒë¼ë¯¸í„° ---
MICROSTEP = 1
STEPS_PER_REV = 200 * MICROSTEP
DEG_PER_STEP = 360.0 / STEPS_PER_REV

DIR_SETUP_S = 0.000010
STEP_PULSE_MIN_S = 0.000010

def gpio_init():
    h = lgpio.gpiochip_open(0)
    for m in MOTORS:
        lgpio.gpio_claim_output(h, 0, m["step"], 0)
        lgpio.gpio_claim_output(h, 0, m["dir"], 0)
    return h

def gpio_cleanup(h):
    for m in MOTORS:
        try:
            lgpio.gpio_free(h, m["step"])
            lgpio.gpio_free(h, m["dir"])
        except Exception:
            pass
    lgpio.gpiochip_close(h)

def move_steps(h, motor, steps, direction=1, delay=0.002):
    """ë‹¨ìˆœ ìŠ¤í… êµ¬ë™"""
    step_pin, dir_pin = motor["step"], motor["dir"]

    lgpio.gpio_write(h, dir_pin, direction)
    time.sleep(DIR_SETUP_S)

    for _ in range(steps):
        lgpio.gpio_write(h, step_pin, 1)
        time.sleep(delay/2)
        lgpio.gpio_write(h, step_pin, 0)
        time.sleep(delay/2)

    # ëª¨í„° ë„ê¸° (DIR, STEP ëª¨ë‘ LOW)
    lgpio.gpio_write(h, step_pin, 0)
    lgpio.gpio_write(h, dir_pin, 0)

def main():
    h = gpio_init()
    try:
        while True:
            for m in MOTORS:
                print(f"ğŸ‘‰ {m['name']} ì‹œê³„ ë°©í–¥ íšŒì „ ì¤‘...")
                move_steps(h, m, steps=200, direction=1, delay=0.002)  # 200ìŠ¤í…(=1íšŒì „)
                print(f"âœ… {m['name']} ì™„ë£Œ, ëª¨í„° OFF")
                time.sleep(1)  # ëª¨í„° ëˆ ìƒíƒœì—ì„œ ì ì‹œ ëŒ€ê¸°

                print(f"ğŸ‘‰ {m['name']} ë°˜ì‹œê³„ ë°©í–¥ íšŒì „ ì¤‘...")
                move_steps(h, m, steps=200, direction=0, delay=0.002)
                print(f"âœ… {m['name']} ì™„ë£Œ, ëª¨í„° OFF")
                time.sleep(1)

    except KeyboardInterrupt:
        print("\nì •ì§€: GPIO í•´ì œ ì¤‘...")
    finally:
        gpio_cleanup(h)
        print("GPIO í•´ì œ ì™„ë£Œ. í”„ë¡œê·¸ë¨ ì¢…ë£Œ.")

if __name__ == "__main__":
    main()
ğŸ”‘ ë™ì‘ ì„¤ëª…
ëª¨í„°1ì„ ì‹œê³„ ë°©í–¥ í•œ ë°”í€´ â†’ ë©ˆì¶¤,

ì ì‹œ ëŒ€ê¸° í›„ ë°˜ì‹œê³„ ë°©í–¥ í•œ ë°”í€´ â†’ ë©ˆì¶¤,

ë‹¤ìŒ ëª¨í„°(ëª¨í„°2, 3, 4) ìˆœì„œëŒ€ë¡œ ë°˜ë³µ.

ê° ëª¨í„° ëŒë¦° ë’¤ì—ëŠ” STEP=0, DIR=0ìœ¼ë¡œ ë‚´ë ¤ì£¼ì–´ ë“œë¼ì´ë²„ê°€ Idle ìƒíƒœê°€ ë©ë‹ˆë‹¤.

ğŸ‘‰ í˜¹ì‹œ â€œëª¨í„°ë¥¼ ëŒë¦¬ê³  ì™„ì „íˆ ì „ì›(ì „ë¥˜)ê¹Œì§€ ë„ê³  ì‹¶ë‹¤â€ëŠ” ì˜ë¯¸ì¼ê¹Œìš”? (ì¦‰, ë“œë¼ì´ë²„ Enable í•€ì„ ì œì–´í•´ì„œ ì „ë¥˜ ìì²´ë¥¼ ì°¨ë‹¨í•˜ëŠ” ë°©ì‹)
ì•„ë‹ˆë©´ ì§€ê¸ˆì²˜ëŸ¼ STEP ì‹ í˜¸ë¥¼ ë©ˆì¶”ê³  DIRì„ 0ìœ¼ë¡œ ë‘ëŠ” ê²ƒìœ¼ë¡œ ì¶©ë¶„í• ê¹Œìš”?

ë‚˜ì˜ ë§:
ã…‡ã…‡ã…‡ ì”ë¥˜ì „ì› ìì²´ë¥¼ ì°¨ë‹¨í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ í•˜ê³ ì‹¶ì–´
ChatGPTì˜ ë§:
ì¢‹ìŠµë‹ˆë‹¤ ğŸ‘ ë§ì”€í•˜ì‹  ê±´ ëª¨í„° ë“œë¼ì´ë²„(TB6600)ì˜ Enable í•€(ë³´í†µ EN+, EN-)ì„ ì œì–´í•´ì„œ ì½”ì¼ ì „ë¥˜ë¥¼ ì™„ì „íˆ ì°¨ë‹¨í•˜ëŠ” ë°©ì‹ì´ì—ìš”.

ğŸ” ì›ë¦¬
TB6600ì€ EN í•€ì´ í™œì„±í™”(Enable) ìƒíƒœì¼ ë•Œë§Œ ëª¨í„°ì— ì „ë¥˜ë¥¼ í˜ë¦½ë‹ˆë‹¤.

ì¼ë°˜ì ìœ¼ë¡œ EN í•€ LOW â†’ í™œì„±í™”(ëª¨í„° êµ¬ë™ë¨), EN í•€ HIGH â†’ ë¹„í™œì„±í™”(ëª¨í„° ì½”ì¼ ì „ë¥˜ ì°¨ë‹¨) ë¡œ ë™ì‘í•©ë‹ˆë‹¤.
(ë“œë¼ì´ë²„ ëª¨ë¸/ì„¸íŒ…ì— ë”°ë¼ ë°˜ëŒ€ì¼ ìˆ˜ë„ ìˆìœ¼ë‹ˆ ë°ì´í„°ì‹œíŠ¸ í™•ì¸ í•„ìš”í•©ë‹ˆë‹¤.)

ë”°ë¼ì„œ ëª¨í„°ë¥¼ ëŒë¦´ ë•Œ â†’ Enable ON, ëë‚˜ë©´ Enable OFF ë¡œ ì œì–´í•˜ë©´ ì”ë¥˜ì „ë¥˜ê°€ ì‚¬ë¼ì§‘ë‹ˆë‹¤.

âœ… ì½”ë“œ ìˆ˜ì • ì˜ˆì‹œ (Enable í•€ ì œì–´ ì¶”ê°€)
í•€ ë²ˆí˜¸ì— Enable í•€ì„ í•˜ë‚˜ì”© ì§€ì •í•œë‹¤ê³  ê°€ì •í•´ë³¼ê²Œìš” (ì˜ˆ: BCM 6, 13, 19, 26).
ğŸ‘‰ ì‹¤ì œ ë¼ì¦ˆë² ë¦¬íŒŒì´ ë°°ì„ ì— ë§ì¶° ë°”ê¾¸ì‹œë©´ ë©ë‹ˆë‹¤.

# stepper_4motor_with_enable.py
import lgpio
import time

# --- ëª¨í„° í•€ ì„¤ì • (BCM ë²ˆí˜¸) ---
step_pin_1, dir_pin_1, en_pin_1 = 17, 18, 6
step_pin_2, dir_pin_2, en_pin_2 = 27, 22, 13
step_pin_3, dir_pin_3, en_pin_3 = 23, 24, 19
step_pin_4, dir_pin_4, en_pin_4 = 10, 9, 26

MOTORS = [
    {"step": step_pin_1, "dir": dir_pin_1, "en": en_pin_1, "name": "ëª¨í„°1"},
    {"step": step_pin_2, "dir": dir_pin_2, "en": en_pin_2, "name": "ëª¨í„°2"},
    {"step": step_pin_3, "dir": dir_pin_3, "en": en_pin_3, "name": "ëª¨í„°3"},
    {"step": step_pin_4, "dir": dir_pin_4, "en": en_pin_4, "name": "ëª¨í„°4"},
]

DIR_SETUP_S = 0.000010
STEP_PULSE_MIN_S = 0.000010

def gpio_init():
    h = lgpio.gpiochip_open(0)
    for m in MOTORS:
        lgpio.gpio_claim_output(h, 0, m["step"], 0)
        lgpio.gpio_claim_output(h, 0, m["dir"], 0)
        lgpio.gpio_claim_output(h, 0, m["en"], 1)  # ì‹œì‘ ì‹œ Disable ìƒíƒœ
    return h

def gpio_cleanup(h):
    for m in MOTORS:
        try:
            lgpio.gpio_free(h, m["step"])
            lgpio.gpio_free(h, m["dir"])
            lgpio.gpio_free(h, m["en"])
        except Exception:
            pass
    lgpio.gpiochip_close(h)

def enable_motor(h, motor):
    # EN í•€ LOW â†’ Enable (TB6600 ê¸°ì¤€)
    lgpio.gpio_write(h, motor["en"], 0)

def disable_motor(h, motor):
    # EN í•€ HIGH â†’ Disable (TB6600 ê¸°ì¤€)
    lgpio.gpio_write(h, motor["en"], 1)

def move_steps(h, motor, steps, direction=1, delay=0.002):
    step_pin, dir_pin = motor["step"], motor["dir"]

    # ëª¨í„° ì¼œê¸°
    enable_motor(h, motor)
    time.sleep(0.01)  # ì•ˆì •í™” ì‹œê°„

    lgpio.gpio_write(h, dir_pin, direction)
    time.sleep(DIR_SETUP_S)

    for _ in range(steps):
        lgpio.gpio_write(h, step_pin, 1)
        time.sleep(delay/2)
        lgpio.gpio_write(h, step_pin, 0)
        time.sleep(delay/2)

    # ëª¨í„° ë„ê¸° (ì „ë¥˜ ì°¨ë‹¨)
    disable_motor(h, motor)

def main():
    h = gpio_init()
    try:
        while True:
            for m in MOTORS:
                print(f"ğŸ‘‰ {m['name']} ì‹œê³„ ë°©í–¥ íšŒì „ ì¤‘...")
                move_steps(h, m, steps=200, direction=1, delay=0.002)
                print(f"âœ… {m['name']} ì™„ë£Œ â†’ ì „ë¥˜ ì°¨ë‹¨")
                time.sleep(1)

                print(f"ğŸ‘‰ {m['name']} ë°˜ì‹œê³„ ë°©í–¥ íšŒì „ ì¤‘...")
                move_steps(h, m, steps=200, direction=0, delay=0.002)
                print(f"âœ… {m['name']} ì™„ë£Œ â†’ ì „ë¥˜ ì°¨ë‹¨")
                time.sleep(1)

    except KeyboardInterrupt:
        print("\nì •ì§€: GPIO í•´ì œ ì¤‘...")
    finally:
        gpio_cleanup(h)
        print("GPIO í•´ì œ ì™„ë£Œ. í”„ë¡œê·¸ë¨ ì¢…ë£Œ.")

if __name__ == "__main__":
    main()
ğŸ”‘ ì •ë¦¬
Enable í•€ ì¶”ê°€: ëª¨í„°ê°€ í•„ìš”í•  ë•Œë§Œ ì¼œê³ , ëë‚˜ë©´ êº¼ì„œ ì”ë¥˜ì „ë¥˜ ì™„ì „ ì°¨ë‹¨.

gpio_init()ì—ì„œ EN í•€ì„ **ê¸°ë³¸ HIGH(Disable)**ë¡œ ì¡ì•„ë‘¡ë‹ˆë‹¤.

move_steps()ì—ì„œ ëŒë¦¬ê¸° ì „ Enable â†’ ëŒë¦¬ê³  ë‚˜ì„œ Disable.

ğŸ‘‰ ì§ˆë¬¸: ì§€ê¸ˆ ì“°ì‹œëŠ” TB6600 ë³´ë“œì—ì„œ Enable í•€(EN+/EN-)ì„ ë¼ì¦ˆë² ë¦¬íŒŒì´ì— ì—°ê²°í•˜ì‹¤ ìˆ˜ ìˆë‚˜ìš”?
ê·¸ í•€ ì—°ê²° ì—¬ë¶€ì— ë”°ë¼ ì‹¤ì œë¡œ â€œì”ë¥˜ì „ì› ì°¨ë‹¨â€ì´ ê°€ëŠ¥í•´ì§‘ë‹ˆë‹¤.

ë‚˜ì˜ ë§:
í•€ë‘ê°œë§Œ ì‚¬ìš©í•˜ëŠ” ì½”ë“œë¡œ ìˆ˜ì •
ChatGPTì˜ ë§:
ì¢‹ìŠµë‹ˆë‹¤ ğŸ‘ ë§ì”€í•˜ì‹  ëŒ€ë¡œë¼ë©´ STEP, DIR ë‘ ê°œ í•€ë§Œ ì“°ê³  Enable í•€ì€ ì—°ê²°í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì˜ë¯¸ë„¤ìš”.
ì¦‰, ëª¨í„°ëŠ” í•­ìƒ ì „ì›ì´ ì¸ê°€ëœ ìƒíƒœì—ì„œ, STEP ì‹ í˜¸ë§Œ ì¤„ ë•Œë§Œ ì›€ì§ì´ê³ , ë©ˆì¶”ë©´ ê·¸ëŒ€ë¡œ í™€ë”© í† í¬(ì”ë¥˜ì „ë¥˜)ê°€ ìœ ì§€ë©ë‹ˆë‹¤.

í•˜ì§€ë§Œ ì§ˆë¬¸ì—ì„œ â€œí•€ ë‘ê°œë§Œâ€ì´ë¼ê³  í•˜ì…¨ìœ¼ë‹ˆ, STEP + DIRë§Œ ì‚¬ìš©í•˜ëŠ” ê°€ì¥ ë‹¨ìˆœí•œ ì½”ë“œë¡œ ë¦¬íŒ©í† ë§ í•´ë“œë¦¬ê² ìŠµë‹ˆë‹¤.

âœ… STEP, DIR ë‘ ê°œë§Œ ì“°ëŠ” ì½”ë“œ
# stepper_4motor_step_dir_only.py
import lgpio
import time

# --- ëª¨í„° í•€ ì„¤ì • (BCM ë²ˆí˜¸) ---
step_pin_1, dir_pin_1 = 17, 18
step_pin_2, dir_pin_2 = 27, 22
step_pin_3, dir_pin_3 = 23, 24
step_pin_4, dir_pin_4 = 10, 9

MOTORS = [
    {"step": step_pin_1, "dir": dir_pin_1, "name": "ëª¨í„°1"},
    {"step": step_pin_2, "dir": dir_pin_2, "name": "ëª¨í„°2"},
    {"step": step_pin_3, "dir": dir_pin_3, "name": "ëª¨í„°3"},
    {"step": step_pin_4, "dir": dir_pin_4, "name": "ëª¨í„°4"},
]

DIR_SETUP_S = 0.000010
STEP_PULSE_MIN_S = 0.000010

def gpio_init():
    h = lgpio.gpiochip_open(0)
    for m in MOTORS:
        lgpio.gpio_claim_output(h, 0, m["step"], 0)
        lgpio.gpio_claim_output(h, 0, m["dir"], 0)
    return h

def gpio_cleanup(h):
    for m in MOTORS:
        try:
            lgpio.gpio_free(h, m["step"])
            lgpio.gpio_free(h, m["dir"])
        except Exception:
            pass
    lgpio.gpiochip_close(h)

def move_steps(h, motor, steps, direction=1, delay=0.002):
    """STEP/DIR ë‘ í•€ë§Œ ì‚¬ìš©í•´ì„œ ë‹¨ìˆœ êµ¬ë™"""
    step_pin, dir_pin = motor["step"], motor["dir"]

    # ë°©í–¥ ì„¤ì •
    lgpio.gpio_write(h, dir_pin, direction)
    time.sleep(DIR_SETUP_S)

    # ì§€ì •ëœ ìŠ¤í… ìˆ˜ ë§Œí¼ í„ìŠ¤ ë°œìƒ
    for _ in range(steps):
        lgpio.gpio_write(h, step_pin, 1)
        time.sleep(delay/2)
        lgpio.gpio_write(h, step_pin, 0)
        time.sleep(delay/2)

def main():
    h = gpio_init()
    try:
        while True:
            for m in MOTORS:
                print(f"ğŸ‘‰ {m['name']} ì‹œê³„ ë°©í–¥ íšŒì „ ì¤‘...")
                move_steps(h, m, steps=200, direction=1, delay=0.002)  # 200ìŠ¤í…
                print(f"âœ… {m['name']} ì™„ë£Œ")
                time.sleep(1)

                print(f"ğŸ‘‰ {m['name']} ë°˜ì‹œê³„ ë°©í–¥ íšŒì „ ì¤‘...")
                move_steps(h, m, steps=200, direction=0, delay=0.002)
                print(f"âœ… {m['name']} ì™„ë£Œ")
                time.sleep(1)

    except KeyboardInterrupt:
        print("\nì •ì§€: GPIO í•´ì œ ì¤‘...")
    finally:
        gpio_cleanup(h)
        print("GPIO í•´ì œ ì™„ë£Œ. í”„ë¡œê·¸ë¨ ì¢…ë£Œ.")

if __name__ == "__main__":
    main()
ğŸ”‘ ì„¤ëª…
í•„ìš”í•œ í•€ = STEP, DIR ë‘ ê°œë§Œ ì‚¬ìš©.

Enable í•€ì€ ì“°ì§€ ì•Šìœ¼ë¯€ë¡œ ëª¨í„°ê°€ ë©ˆì¶˜ ë’¤ì—ë„ ì”ë¥˜ì „ë¥˜ê°€ ê³„ì† íë¦…ë‹ˆë‹¤ â†’ í•­ìƒ í™€ë”©í† í¬ ìœ ì§€.

move_steps() í•¨ìˆ˜ì—ì„œ ì›í•˜ëŠ” ìŠ¤í… ìˆ˜ë§Œí¼ ë‹¨ìˆœíˆ í„ìŠ¤ë¥¼ ë°œìƒì‹œí‚µë‹ˆë‹¤.

ğŸ‘‰ ë§Œì•½ ì§„ì§œë¡œ â€œëŒë¦¬ê³  ë‚˜ì„œ ì „ë¥˜ê¹Œì§€ êº¼ì„œ ëª¨í„° ì™„ì „íˆ í•´ì œâ€í•˜ê³  ì‹¶ìœ¼ì‹œë©´, Enable í•€ì„ ê¼­ ì—°ê²°í•´ì•¼ í•©ë‹ˆë‹¤. ì§€ê¸ˆ êµ¬ì¡°(í•€ 2ê°œë§Œ ì‚¬ìš©)ì—ì„œëŠ” ì „ë¥˜ë¥¼ ì°¨ë‹¨í•  ìˆ˜ ì—†ëŠ”ë°, ê·¸ë˜ë„ ì´ ë°©ì‹ì´ë©´ ê´œì°®ìœ¼ì‹¤ê¹Œìš”?

ë‚˜ì˜ ë§:
í•€ì€ 3ê°œ ì“°ê³  ëª¨í„°ë¥¼ 2ê°œë§Œ ê°ë„ ì…ë ¥ë°›ê³  ì‚¬ìš©í•˜ìš” ì „ì›ì„ ì°¨ë‹¨í•˜ë„ë¡ ì„¤ì •
ChatGPTì˜ ë§:
ë„¤ ğŸ‘ ì´ë²ˆì—ëŠ” ìš”êµ¬ì‚¬í•­ì„ ì •ë¦¬í•´ë³´ë©´:

í•€ì€ STEP, DIR, EN â†’ 3ê°œ ì‚¬ìš©

ëª¨í„°ëŠ” 2ê°œë§Œ ì œì–´ (ê°ë„ ì…ë ¥ë°›ì•„ì„œ ë™ì‘)

ë™ì‘ì´ ëë‚˜ë©´ EN í•€ì„ HIGH(Disable)ë¡œ í•´ì„œ ì „ë¥˜ ì°¨ë‹¨

ì¦‰, ìµœì†Œ êµ¬ì„±(ëª¨í„° 2ê°œ Ã— 3í•€ì”©)ìœ¼ë¡œ ì œì–´í•˜ê³ , ë™ì‘ í›„ ì”ë¥˜ ì „ë¥˜ê¹Œì§€ êº¼ì£¼ëŠ” ì½”ë“œì…ë‹ˆë‹¤.

âœ… ì½”ë“œ ì˜ˆì‹œ (ëª¨í„° 2ê°œ, STEP+DIR+EN)
# stepper_2motor_with_enable.py
import lgpio
import time
import math

# --- ëª¨í„° í•€ ì„¤ì • (BCM ë²ˆí˜¸) ---
# ì˜ˆì‹œ í•€ ë²ˆí˜¸: ì‹¤ì œ ë°°ì„ ì— ë§ê²Œ ìˆ˜ì •í•˜ì„¸ìš”
step_pin_1, dir_pin_1, en_pin_1 = 17, 18, 6
step_pin_2, dir_pin_2, en_pin_2 = 27, 22, 13

MOTORS = [
    {"step": step_pin_1, "dir": dir_pin_1, "en": en_pin_1, "name": "ëª¨í„°1"},
    {"step": step_pin_2, "dir": dir_pin_2, "en": en_pin_2, "name": "ëª¨í„°2"},
]

# --- ìŠ¤í…ëª¨í„° íŒŒë¼ë¯¸í„° ---
MICROSTEP = 1
STEPS_PER_REV = 200 * MICROSTEP
DEG_PER_STEP = 360.0 / STEPS_PER_REV

DIR_SETUP_S = 0.000010
STEP_PULSE_MIN_S = 0.000010


def gpio_init():
    h = lgpio.gpiochip_open(0)
    for m in MOTORS:
        lgpio.gpio_claim_output(h, 0, m["step"], 0)
        lgpio.gpio_claim_output(h, 0, m["dir"], 0)
        lgpio.gpio_claim_output(h, 0, m["en"], 1)  # ì‹œì‘ ì‹œ Disable (ì „ë¥˜ ì°¨ë‹¨ ìƒíƒœ)
    return h


def gpio_cleanup(h):
    for m in MOTORS:
        try:
            lgpio.gpio_free(h, m["step"])
            lgpio.gpio_free(h, m["dir"])
            lgpio.gpio_free(h, m["en"])
        except Exception:
            pass
    lgpio.gpiochip_close(h)


def enable_motor(h, motor):
    lgpio.gpio_write(h, motor["en"], 0)  # EN LOW â†’ Enable (TB6600 ê¸°ì¤€)
    time.sleep(0.01)


def disable_motor(h, motor):
    lgpio.gpio_write(h, motor["en"], 1)  # EN HIGH â†’ Disable (ì „ë¥˜ ì°¨ë‹¨)


def move_to_angle(h, motor, current_angle, target_angle, delay=0.002):
    step_pin, dir_pin = motor["step"], motor["dir"]

    delta_angle = target_angle - current_angle
    steps_needed = int(round(abs(delta_angle) / DEG_PER_STEP))
    if steps_needed == 0:
        return current_angle

    # ëª¨í„° ì „ì› ì¼œê¸°
    enable_motor(h, motor)

    direction = 1 if delta_angle > 0 else 0
    lgpio.gpio_write(h, dir_pin, direction)
    time.sleep(DIR_SETUP_S)

    for _ in range(steps_needed):
        lgpio.gpio_write(h, step_pin, 1)
        time.sleep(delay/2)
        lgpio.gpio_write(h, step_pin, 0)
        time.sleep(delay/2)

    # ë™ì‘ ì™„ë£Œ í›„ ì „ë¥˜ ì°¨ë‹¨
    disable_motor(h, motor)

    return target_angle


def main():
    h = gpio_init()
    current_angles = [0.0, 0.0]  # ëª¨í„°1, ëª¨í„°2ì˜ í˜„ì¬ ê°ë„

    try:
        while True:
            raw = input("ê°ë„ ì…ë ¥ (ì˜ˆ: 90 180) ë˜ëŠ” q ì¢…ë£Œ: ").strip()
            if raw.lower() in ("q", "quit", "exit"):
                break

            try:
                target_angles = list(map(float, raw.split()))
            except ValueError:
                print(" ìˆ«ì 2ê°œë¥¼ ì…ë ¥í•˜ì„¸ìš”. ì˜ˆ: 90 180")
                continue

            if len(target_angles) != 2:
                print(" ëª¨í„°1, ëª¨í„°2 ê°ë„ 2ê°œë¥¼ ì…ë ¥í•´ì•¼ í•©ë‹ˆë‹¤.")
                continue

            for i, m in enumerate(MOTORS):
                print(f" {m['name']} {current_angles[i]:.1f}Â° â†’ {target_angles[i]:.1f}Â° ì´ë™ ì¤‘...")
                current_angles[i] = move_to_angle(h, m, current_angles[i], target_angles[i])
                print(f" {m['name']} ì™„ë£Œ (ì „ë¥˜ ì°¨ë‹¨ë¨)")

    except KeyboardInterrupt:
        print("\nì •ì§€: GPIO í•´ì œ ì¤‘...")
    finally:
        gpio_cleanup(h)
        print("GPIO í•´ì œ ì™„ë£Œ. í”„ë¡œê·¸ë¨ ì¢…ë£Œ.")


if __name__ == "__main__":
    main()
 ë™ì‘ ë°©ì‹
ê°ë„ ì…ë ¥ â†’ ì˜ˆ: 90 180 â†’ ëª¨í„°1ì€ 90Â°, ëª¨í„°2ëŠ” 180Â°ë¡œ ì´ë™

ëª¨í„° ë™ì‘ ì‹œ EN í•€ LOW â†’ ëª¨í„°ì— ì „ë¥˜ ê³µê¸‰

ì´ë™ ì™„ë£Œ í›„ EN í•€ HIGH â†’ ì „ë¥˜ ì°¨ë‹¨, ì”ë¥˜ í† í¬ í•´ì œ

ìˆœì°¨ ì‹¤í–‰: ëª¨í„°1 ì™„ë£Œ â†’ ëª¨í„°2 ì‹¤í–‰

 ì‹¤ì œ ë°°ì„ ì—ì„œ TB6600ì˜ EN+ / EN- í•€ì„ ë¼ì¦ˆë² ë¦¬íŒŒì´ GPIOì™€ GNDì— ì—°ê²°í•˜ì…”ì•¼ ì „ë¥˜ ì°¨ë‹¨ì´ ì œëŒ€ë¡œ ë™ì‘í•©ë‹ˆë‹¤.

ì›í•˜ì‹œë©´ ì œê°€ TB6600 í•€ ë°°ì¹˜(EN+/EN-, DIR+/DIR-, PUL+/PUL-) ê¸°ì¤€ìœ¼ë¡œ ë¼ì¦ˆë² ë¦¬íŒŒì´ ì—°ê²° ì˜ˆì‹œ ê·¸ë¦¼ë„ ê·¸ë ¤ë“œë¦´ê¹Œìš”?


ê°œë°œì ëª¨ë“œ


ì„ íƒëœ íŒŒì¼ ì—†ìŒì„ íƒëœ íŒŒì¼ ì—†ìŒ
ChatGPTëŠ” ì‹¤ìˆ˜ë¥¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì¤‘ìš”í•œ ì •ë³´ëŠ” ì¬ì°¨ í™•ì¸í•˜ì„¸ìš”.
